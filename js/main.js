/*
* Задания на урок:
1) Удалить все рекламные блоки со страницы (правая часть сайта)
2) Изменить жанр фильма, поменять "комедия" на "драма"
3) Изменить задний фон с постером фильма на изображение "bg.jpg". Оно лежит в папке img.
Реализовать только при помощи JS
4) Список фильмов на странице сформировать на основании данных из этого JS файла.
Отсортировать их по алфавиту 
5) Добавить нумерацию выведенных фильмов */

/* Задания на урок:
1) Реализовать функционал, что после заполнения формы и нажатия кнопки "Подтвердить" - 
новый фильм добавляется в список. Страница не должна перезагружаться.
Новый фильм должен добавляться в movieDB.movies.
Для получения доступа к значению input - обращаемся к нему как input.value;
P.S. Здесь есть несколько вариантов решения задачи, принимается любой, но рабочий.
2) Если название фильма больше, чем 21 символ - обрезать его и добавить три точки
3) При клике на мусорную корзину - элемент будет удаляться из списка (сложно)
4) Если в форме стоит галочка "Сделать любимым" - в консоль вывести сообщение: 
"Добавляем любимый фильм"
5) Фильмы должны быть отсортированы по алфавиту */


//Урок№30.Практика.Задание на обработку действий со страницей.
//Урок№33.Используем события на странице проекта.

"use strict";



//a = a + 1;//записываем сюда предыдущее значение
//a += 1;//упрощенный синтаксис,это две абсолютно индентичные команды

//a = a + "aaa";
//a += "aaa";//со строками будет все точно также работать

//если картинка img много весит может возникнуть такая ситуация что скрипт script прогрузится быстрее
//чем картинка,такое может случится и тогда наш скрипт не сможет найти определенные элементы
//то есть мы в js файле что то получали а если этих элементов не существует еще на странице то мы получим ошибку
//и чтобы такого не случалось в JavaScript есть два события которые мы тоже можем отлавливать
//первое событие называется load и как понятно из его названия оно срабатывает только тогда когда
//когда наша страница полностью готова,она полностью загрузилась у нее загрузились стили которые пришли с 
//какого то удаленного сервера,все картинки у нас при этом уже будут готовы,страница готова к работе
//но опять же если страница много весит ожидание может идти и 3 и 5 секунд. 

//поэтому в реальных проектах не всегда используется load,чаще всего используется более простое событие
//которое называется downContentLoaded(мы дожидаемся не полной загрузки всех элементов на странице а только 
//построение DOM структуру)когда наше дерево тегов сформируется полноценно то есть мы с ним можем нормально работать
//тогда и наши скрипты с вами запустятся,остальные картинки,скрипты,стили будут подгружатся в фоновом режиме они ни на
//что влиять не будут,чтобы сказать четко нашему js коду чтобы он брал и ждал загрузки DOM дерева нам необходимо 

//выделить весь код мы его с вами вырезаем обращаемся к нашему документу document
//на него навешиваем обработчик событий
document.addEventListener('DOMContentLoaded', () => {//первый аргумент будет говорить что DOM структура загружена
    //сюда в callback помещаем весь наш код который был до этого, который мы весь скопировали и вырезали
    //код расположенный ниже сработает только тогда когда DOM структура будет загружена
    const movieDB = {
        movies: [
            "Логан",
            "Лига справедливости",
            "Ла-ла лэнд",
            "Одержимость",
            "Скотт Пилигрим против..."
        ]
    };
    
    //Задача№1
    const adv = document.querySelectorAll('.promo__adv img'),
          poster = document.querySelector('.promo__bg'), //указывает что нам необходим только один этот элемент
          genre = poster.querySelector('.promo__genre'),//теперь мы можем получить жанр из этого блока- .promo__bg,
    //мы внутри переменной poster, внутри этого элемента
    
          movieList = document.querySelector('.promo__interactive-list'),//задача№3
    //используем querySelector а не querySelectorAll чтобы получить первый элемент со страницы по данному селектору
          
        //Задача№2
          addForm = document.querySelector('form.add'), //воспользуюсь такой формой у которой есть .add

          addInput = addForm.querySelector('.adding__input'),
          checkbox = addForm.querySelector('[type="checkbox"]');//удобно искать checkbox через атрибуты,я выделю ту 
          //галочку которая мне понадобится внутри формы

          //назначим обработчик события на нашу форму
          //чтобы отследить отправку нашей формы есть обработчик событий который называется submit 
        addForm.addEventListener('submit', (event) => { //прописав submit нам необходимо прописать callback функцию
          //нам обязательно понадобится обьект события event,когда намнеобходимо отменить стандартное поведение браузера
          //мы в самом начале сразу же прописывали event.preventDefault();
          event.preventDefault();//таким образом когда я сейчас буду нажимать на кнопку Отправить у нас страница не 
          //будет перезагружатся,это один из принципов Ajax технологии про которую мы еще будем говорить
        
          let newFilm = addInput.value;//я обращаюсь к тому input скоторым взаимодействовал пользователь и я проверяю 
          //его value в свойстве value которое есть у input в переменной addInput будет как раз содержатся точто ввел 
          //пользователь
          
          const favorite = checkbox.checked;//обращаемся к переменной checkbox которая расположена выше,это галочка  
          //которая может быть либо отмечена либо неотмечена(то есть либо да либо нет).Будет булиновое значение и для 
          //того чтобы его получить нам необходимо обратится к checkbox.checked(либо true когда галочка отмечена либо 
          //false когда галочка не отмечена)
          //У нас есть какие то данные и когда форма будет подтверждатся нам необходимо будет создавать новый фильм и 
          //помещать его в список слева 
          
          if (newFilm) {//это условие будет выполнится только тогда input value заполнен(помним что пустая строка 
            //это false) то есть если в нем не пустая строка то условие выполнится,если пустая строка то условие не 
            //выполнится потому что в логическом контексте будет false
            //если пользователь что то ввел то тогда мы создаем новые фильмы помещаем ее в базу данных

            if (newFilm.length > 21) { 
              //если название фильма будет больше чем 21 символ то мы будем чтото делать,если по простому разбить задачу
              //нам необходимо разбить задачу отрезать первые 21 символ от этого названия и к ним также 
              //добавить троеточие,вспоминаем методы строк которые мы проходили
              newFilm = `${newFilm.substring(0, 22)}...`;//заменяем старую строчку на новый вариант,говорим что 
              //обращаемся к старому значению newFilms,используем метод substring,говорим что хотим вырезать 
              //с 0 позиции и до 22 невключая
              
            }//этим одним условием проверяем длину нашего фильма
              
            if (favorite) { //4 задание
              console.log("Добавляем любимый фильм"); //если эта галочка отмечена(true) 
            } //то мы сюда добавляем эту строку добавляем любимый фильм
            //конечно действия могут быть и посложнее но ограничимся этим

            movieDB.movies.push(newFilm);//наши фильмы это массив и тот фильм который был введен пользователем просто 
            //туда попадает,всю информацию которую мы получаем от пользователя,мы получаем ее в текстовом виде
          
            //когда мы запушили новый фильм мы с вами должны отсортировать все эти фильмы по алфавиту
            sortArr(movieDB.movies);//подставил сюда функцию которая будет сортировать наш главный массив с фильмами
            //сейчас наши функциональности уже начинают переиспользоваться

            //функционал movieDB.movies.forEach((film, i) => {(146строка) мне необходимо переиспользовать вот здесь,
            //на этом этапе когда сабмитится наша новая форма addForm.addEventListener('submit' (84строка)
            //то есть мы отправляем новые данные у нас в списке фильмов появляется новый элемент, на основании всех 
            //элементов фильма внутри массива мы и построим список фильмов который выведется на страницу       

            //здесь внизу идет создание новых фильмов,на основании новых данных мы с вами опять построим список фильмов
            createMovieList(movieDB.movies, movieList); //мы ее как раз для этого и создавали 165 строка
            //на основании уже немножко измененных данных все тот же parent мы берем и создаем наши новые элементы 
            //в конце нам надо очистить форму чтобы из нее все данные исчезли
          }
          
          
          event.target.reset();//поэтому мы обращаемся к самой форме и вызываем метод reset(сбросить нашу форму)
          //но здесь есть одна особенность мы можем использовать обект событие (event)
          //мы при помощи event.target.reset(); обращались к самому элементу на котором происходит событие 
          //и здесь можно сделать точно также
        }); 
        //Создаем функцию по удалению рекламы
        const deleteAdv = (arr) => {//когда мы создаем function Expression только сюда помещаем стрелочную функцию
          //мы не можем просто так взять и удалить через remove() потому что у него просто не существует методов
          //(нету HTMLCollection) нам необходимо взять каждый элемент этого псевдомассива и уже последовательно 
          //их удалить

          arr.forEach(item => { //мы получали этот псевдомассив через querySelectorAll значит у него есть метод forEach
            //во внутрь передаем callback функцию говорим что там будет item,это стрелочная функция которая 
            //содержит 1 элемент

            item.remove();//теперь можем взаимодействовать с каждым элементом
          });//но сейчас же я привязываюсь к какому то элементу или элементам на странице
          //я хочу от этого уйти я говорю что буду передавать сюда какой то аргумент например arr
          //который будет определятся уже в момент вызова функции
        };
       

    //рассмотрим 2 вариант как это будет выглядеть с обычной функцией
    //adv.forEach(function (item) { //это безымянная функция котораясоздается здесь и сейчас онапринимает 1аргумент item
    //    item.remove();//который у нас будет приходить из нашего псевдомассива
    //}); //сохранив видим что элементы не появились,но предпочтительнее использовать стрелочную функцию
    
    
    
    
    const makeChanges = () => { //makeChanges сделать какие то изменения на странице
        //следующая задача это взять внутренности которые написаны в элементу genre
      genre.textContent = 'драма';//мы изменяем просто текст, мы используем метод textContent
    
    
      //Задача№3
      poster.style.backgroundImage = 'url("images/bg.jpg")';//изображение заднего фона
    };


    //эта функция будет применять в себя какой то массив она еще не знает какой
    const sortArr = (arr) => {
        arr.sort();
    };
    
    
    //Задача№5
    //movieDB.movies.sort();//sort сортирует все элементы по алфавиту если там строки
    //все сформировали по алфавиту
    
    //console.log(poster.innerHTML);//если мы такимобразом обращаемся к innerHTML то мы просто получаем значение 
    //этого свойства значения со страницы в разделе консоль в браузере,но используется это не часто
    
    
     
    //для того чтобы переиспользовать один и тот же функционал нам это все необходимо обернуть в функцию 
    //ниже создаем новую функцию,строительный блок нашей программы
    function createMovieList(films, parent) {
    //и во внутрь мы перемещаем ту часть что внутри
    //пока что мы привязываем к каким то определенным элементам на странице либо в определенном скрипте
    //мы же хотим сделать чтобы эта функция была полностью независима
    //чтобы она вызывалась и в момент вызова узнавалась с чем она будет работать
    //для этого у меня есть аргументы (films, parent)-films это фильмы с которыми будет работать наша функция
    //и parent какой родительский блог на страничке будет использовать все эти фильмы

        //Задача№4
      //если я хочу полностью очистить этот элемент используем метод innerHTML
      parent.innerHTML = "";//если я запишу туда ничего то элемент очистится, то элемент ничего уже не будет содержать
      //parent говорит что такой родительский элемент мы с вами будем очищать
    
      sortArr(films);//вызываем функцию sortArr и во внутрь помещаем наши фильмы films
      
        //все элементы с которыми мы будем взаимодействовать лежат в базе данных в свойстве movies
      films.forEach((film, i) => { //если нам необходимо что то перебрать прописываем метод forEach
        //film это каждый отдельный фильм который написан у нас в массиве и переменная i которая 
        //содержит номер по порядку

            //добавляем нумерацию выведенных фильмов
            
            //чтобы не городить конструкцию заменяем все таким решением
            //каждый раз когда цикл будет повторятся, наша итерация +=,мы в innerHTML будем добавлять еще какието строки
            //строка на странице при помощи innerHTML интерпретируется как верстка
            parent.innerHTML += ` 
            <li class="promo__interactive-item">${i + 1} ${film}
                <div class="delete"></div>
            </li>
            `;
      });

      //когда наши все фильмы и корзинки сформированы на странице,я буду вешать
      //обработчики событий на каждую из корзинок,если пользователь кликает на нее
      //я буду удалять родителя у этой корзинки(как получить родительский элемент мы говорили в предыдущем уроке)
      //помимо этого нам надо вырезать тот фильм который был удален из базы данных
      //делается это при помощи метода splice() 

      //здесь мне необходимо получить все корзинки я их не буду еще использовать поэтому я прямо
      //на месте их возьму и буду использовать
      document.querySelectorAll('.delete').forEach((btn, i) => {//помещаем сюда селектор delete,говорим что это все 
      //корзинки и прямо здесь же на месте я их переберу при помощи forEach,если мы хотим навесить на различные 
      //элементы одно и тоже событие мы используем forEach,дальше мне понадобится callback функция в которой мне 
      //понадобится два аргумента это каждая отдельная кнопка-корзинка и нумерация,нумерация нам нужна так как нам 
      //необходимо знать номер по порядку у того элемента который мы удаляем,ведь массив содержит элементы строго 
      //по порядку,все это идет после сортировки поэтому у нас ничего не сломается
        btn.addEventListener('click', () => {
          //я обращаюсь к каждой корзинке внутри,навешиваю обработчик событий click во внутрь запускаем callback функцию
          btn.parentElement.remove();//просто говорим удались пожалуйста со страницы
          
          //помимо того что он удалился со страницы удаляем его с базы данных
          movieDB.movies.splice(i, 1);//splice это метод который вырезает определенный элемент с массива,
          //i это тот элемент который только что удалили который перебирается у нас в методе forEach,
          //а второй аргумент это сколько элементов нужно удалить,мне нужно удалить 1элемент из массива под этим номером
          
          //давайте применим рекурсию(это когда функция вызывает сама себя внутри)
          //когда у меня происходит удаление какого то элемента,то есть я нажимаю на корзинку,я хочу чтобы все элементы
          //оставшиеся в массиве они заново перестраивались и нумерация тоже будет заново перестраиваться,за это 
          //отвечает function createMovieList вызовем ее внутри самой же себя
          createMovieList(films, parent);//так должно тоже работать при этом мы отвязываемся от каких то 
          //конкретных элементов movieDB.movies меняем на films, movieList меняем на parent
          //теперь каждый раз когда я буду удалять какой то элемент у меня будет заново перестраиваться этот список
          

        });
      });
    }

    //некоторые программисты делают так,то что мы обьявили выше мы будем
    //вызывать чуть чуть пониже
    deleteAdv(adv);//все реклама будет удалятся 

    makeChanges();

    //функция createMovieList внутри себя будет сортировать элементы и таким образом
    //мы избавимся от лишнего вызова sortArr (удаляем sortArr(movieDB.movies);)
    //когда только загружается страница мне не нужно это сортировать соответственно сортировку
    //мы помещаем в createMovieList(films, parent); то есть мы обьединяем сразу два действия
    
    

    //function expression вызывается только после того как они были созданы
    //мы не можем их выше расположить

    //ну и внизу оставляем такой список наших функций
    createMovieList(movieDB.movies, movieList);
    //первый аргумент это фильмы которые мы будем перебирать,
    //второй аргумент это parent куда мы будем все это помещать это movieList
    
    //каждый раз когда будет вызываться функция createMovieList внутри удаления нашего нового элемента
    //каждый раз наши элементы будут также нормально сортироватся sortArr(films);

});

